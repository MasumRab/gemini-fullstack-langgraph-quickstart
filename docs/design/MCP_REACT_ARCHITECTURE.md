# MCP Integration Strategy: ReAct Architecture

## Status
- **Current Implementation (Plan A):** Tools are bound to the `generate_query` node to fulfill the immediate requirement. However, this node uses `with_structured_output`, which enforces a strict schema. This creates a conflict where the model may be unable to effectively use tools.
- **Proposed Architecture (Plan C):** A robust "ReAct Loop" design that allows the agent to iteratively call tools, observe results, and then generate the final search plan.

## Proposed Design (ReAct Loop)

To fully leverage MCP tools, the graph topology needs to evolve from a linear "Generate Query -> Search" flow to a cyclical "Reason -> Act -> Observe" loop.

### 1. Refactor `generate_query` Node
The `generate_query` node currently serves two purposes: reasoning and formatting. In the ReAct design, these should be separated or handled dynamically.

- **Inputs:** `OverallState`
- **Logic:**
  - Invoke LLM with `bind_tools([MCP_TOOLS, SubmitPlan])`.
  - `SubmitPlan` is a structured tool representing the `SearchQueryList` schema.
  - **Output:** `AIMessage` containing either a standard tool call (e.g., `get_github_issue`) or a `SubmitPlan` call.

### 2. New Node: `execute_tools`
A dedicated node responsible for executing the tool calls generated by the LLM.

- **Inputs:** `AIMessage` with `tool_calls`.
- **Logic:**
  - Iterate through `tool_calls`.
  - Execute each tool using the loaded `MCP_TOOLS` registry/client.
  - Capture outputs (stdout, stderr, or JSON).
  - Create `ToolMessage` objects with the results.
- **Output:** Appends `ToolMessage`s to `state["messages"]`.

### 3. Graph Topology Changes
The graph needs a conditional edge from `generate_query` (or a renamed `planning_agent` node).

```python
# Pseudo-code for Graph Wiring

builder.add_node("planning_agent", planning_agent_node)
builder.add_node("execute_tools", execute_tools_node)

# Conditional Routing
def route_planning(state):
    last_msg = state["messages"][-1]
    
    # Check if we have tool calls
    if not last_msg.tool_calls:
        # Fallback if no actions were identified
        return "finalize_answer"
        
    # Check if the agent wants to submit the final plan
    if any(call.get("name") == "SubmitPlan" for call in last_msg.tool_calls):
        return "web_research"
    
    # Otherwise, continue the ReAct loop by executing tools
    return "execute_tools"

builder.add_conditional_edges("planning_agent", route_planning)
builder.add_edge("execute_tools", "planning_agent") # Feedback loop
```

### 4. Benefits
- **Dynamic Planning:** The agent can check the current date, fetch a Jira ticket, or read a local file *before* deciding what to search for on the web.
- **Robustness:** Eliminates the schema conflict by treating the plan submission as just another tool.

### 5. Migration Steps
1. Create `execute_tools` node.
2. Define `SubmitPlan` Pydantic model as a LangChain tool.
3. Update `generate_query` to use `bind_tools` instead of `with_structured_output`.
4. Update graph edges in `backend/src/agent/graph.py`.
